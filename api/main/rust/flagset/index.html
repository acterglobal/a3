<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Welcome to FlagSet!"><title>flagset - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-b1a3e7f8283b8434.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="flagset" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0-nightly (d5fd09972 2024-01-22)" data-channel="nightly" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../flagset/index.html">flagset</a><span class="version">0.4.4</span></h2></div><div class="sidebar-elems"><ul class="block">
            <li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li></ul></section></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../flagset/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">flagset</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/flagset/lib.rs.html#19-1290">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="welcome-to-flagset"><a class="doc-anchor" href="#welcome-to-flagset">§</a>Welcome to FlagSet!</h2>
<p>FlagSet is a new, ergonomic approach to handling flags that combines the
best of existing crates like <code>bitflags</code> and <code>enumflags</code> without their
downsides.</p>
<h3 id="existing-implementations"><a class="doc-anchor" href="#existing-implementations">§</a>Existing Implementations</h3>
<p>The <code>bitflags</code> crate has long been part of the Rust ecosystem.
Unfortunately, it doesn’t feel like natural Rust. The <code>bitflags</code> crate
uses a wierd struct format to define flags. Flags themselves are just
integers constants, so there is little type-safety involved. But it doesn’t
have any dependencies. It also allows you to define implied flags (otherwise
known as overlapping flags).</p>
<p>The <code>enumflags</code> crate tried to improve on <code>bitflags</code> by using enumerations
to define flags. This was a big improvement to the natural feel of the code.
Unfortunately, there are some design flaws. To generate the flags,
procedural macros were used. This implied two separate crates plus
additional dependencies. Further, <code>enumflags</code> specifies the size of the
flags using a <code>repr($size)</code> attribute. Unfortunately, this attribute
cannot resolve type aliases, such as <code>c_int</code>. This makes <code>enumflags</code> a
poor fit for FFI, which is the most important place for a flags library.
The <code>enumflags</code> crate also disallows overlapping flags and is not
maintained.</p>
<p>FlagSet improves on both of these by adopting the <code>enumflags</code> natural feel
and the <code>bitflags</code> mode of flag generation; as well as additional API usage
niceties. FlagSet has no dependencies and is extensively documented and
tested. It also tries very hard to prevent you from making mistakes by
avoiding external usage of the integer types. FlagSet is also a zero-cost
abstraction: all functions are inlineable and should reduce to the core
integer operations. FlagSet also does not depend on stdlib, so it can be
used in <code>no_std</code> libraries and applications.</p>
<h3 id="defining-flags"><a class="doc-anchor" href="#defining-flags">§</a>Defining Flags</h3>
<p>Flags are defined using the <code>flags!</code> macro:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>flagset::{FlagSet, flags};
<span class="kw">use </span>std::os::raw::c_int;

<span class="macro">flags! </span>{
    <span class="kw">enum </span>FlagsA: u8 {
        Foo,
        Bar,
        Baz,
    }

    <span class="kw">enum </span>FlagsB: c_int {
        Foo,
        Bar,
        Baz,
    }
}</code></pre></div>
<p>Notice that a flag definition looks just like a regular enumeration, with
the addition of the field-size type. The field-size type is required and
can be either a type or a type alias. Both examples are given above.</p>
<p>Also note that the field-size type specifies the size of the corresponding
<code>FlagSet</code> type, not size of the enumeration itself. To specify the size of
the enumeration, use the <code>repr($size)</code> attribute as specified below.</p>
<h3 id="flag-values"><a class="doc-anchor" href="#flag-values">§</a>Flag Values</h3>
<p>Flags often need values assigned to them. This can be done implicitly,
where the value depends on the order of the flags:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>flagset::{FlagSet, flags};

<span class="macro">flags! </span>{
    <span class="kw">enum </span>Flags: u16 {
        Foo, <span class="comment">// Implicit Value: 0b0001
        </span>Bar, <span class="comment">// Implicit Value: 0b0010
        </span>Baz, <span class="comment">// Implicit Value: 0b0100
    </span>}
}</code></pre></div>
<p>Alternatively, flag values can be defined explicitly, by specifying any
<code>const</code> expression:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>flagset::{FlagSet, flags};

<span class="macro">flags! </span>{
    <span class="kw">enum </span>Flags: u16 {
        Foo = <span class="number">0x01</span>,   <span class="comment">// Explicit Value: 0b0001
        </span>Bar = <span class="number">2</span>,      <span class="comment">// Explicit Value: 0b0010
        </span>Baz = <span class="number">0b0100</span>, <span class="comment">// Explicit Value: 0b0100
    </span>}
}</code></pre></div>
<p>Flags can also overlap or “imply” other flags:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>flagset::{FlagSet, flags};

<span class="macro">flags! </span>{
    <span class="kw">enum </span>Flags: u16 {
        Foo = <span class="number">0b0001</span>,
        Bar = <span class="number">0b0010</span>,
        Baz = <span class="number">0b0110</span>, <span class="comment">// Implies Bar
        </span>All = (Flags::Foo | Flags::Bar | Flags::Baz).bits(),
    }
}</code></pre></div>
<h3 id="specifying-attributes"><a class="doc-anchor" href="#specifying-attributes">§</a>Specifying Attributes</h3>
<p>Attributes can be used on the enumeration itself or any of the values:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>flagset::{FlagSet, flags};

<span class="macro">flags! </span>{
    <span class="attr">#[derive(PartialOrd, Ord)]
    </span><span class="kw">enum </span>Flags: u8 {
        Foo,
        <span class="attr">#[deprecated]
        </span>Bar,
        Baz,
    }
}</code></pre></div>
<h3 id="collections-of-flags"><a class="doc-anchor" href="#collections-of-flags">§</a>Collections of Flags</h3>
<p>A collection of flags is a <code>FlagSet&lt;T&gt;</code>. If you are storing the flags in
memory, the raw <code>FlagSet&lt;T&gt;</code> type should be used. However, if you want to
receive flags as an input to a function, you should use
<code>impl Into&lt;FlagSet&lt;T&gt;&gt;</code>. This allows for very ergonomic APIs:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>flagset::{FlagSet, flags};

<span class="macro">flags! </span>{
    <span class="kw">enum </span>Flags: u8 {
        Foo,
        Bar,
        Baz,
    }
}

<span class="kw">struct </span>Container(FlagSet&lt;Flags&gt;);

<span class="kw">impl </span>Container {
    <span class="kw">fn </span>new(flags: <span class="kw">impl </span>Into&lt;FlagSet&lt;Flags&gt;&gt;) -&gt; Container {
        Container(flags.into())
    }
}

<span class="macro">assert_eq!</span>(Container::new(Flags::Foo | Flags::Bar).<span class="number">0</span>.bits(), <span class="number">0b011</span>);
<span class="macro">assert_eq!</span>(Container::new(Flags::Foo).<span class="number">0</span>.bits(), <span class="number">0b001</span>);
<span class="macro">assert_eq!</span>(Container::new(<span class="prelude-val">None</span>).<span class="number">0</span>.bits(), <span class="number">0b000</span>);</code></pre></div>
<h3 id="operations"><a class="doc-anchor" href="#operations">§</a>Operations</h3>
<p>Operations can be performed on a <code>FlagSet&lt;F&gt;</code> or on individual flags:</p>
<div><table><thead><tr><th>Operator</th><th>Assignment Operator</th><th>Meaning</th></tr></thead><tbody>
<tr><td>|</td><td>|=</td><td>Union</td></tr>
<tr><td>&amp;</td><td>&amp;=</td><td>Intersection</td></tr>
<tr><td>^</td><td>^=</td><td>Toggle specified flags</td></tr>
<tr><td>-</td><td>-=</td><td>Difference</td></tr>
<tr><td>%</td><td>%=</td><td>Symmetric difference</td></tr>
<tr><td>!</td><td></td><td>Toggle all flags</td></tr>
</tbody></table>
</div></div></details><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.flags.html" title="macro flagset::flags">flags</a></div><div class="desc docblock-short">Define flag value using the <code>enum</code> syntax. See below for details.</div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.FlagSet.html" title="struct flagset::FlagSet">FlagSet</a></div></li><li><div class="item-name"><a class="struct" href="struct.InvalidBits.html" title="struct flagset::InvalidBits">InvalidBits</a></div><div class="desc docblock-short">Error type returned when creating a new flagset from bits is invalid or undefined.</div></li></ul></section></div></main></body></html>