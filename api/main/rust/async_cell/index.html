<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The key type of this crate is `AsyncCell` which can be found in both thread-safe and single-threaded variants. It is intended as a useful async primitive which can replace more expensive channels in a fair number of cases."><title>async_cell - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-b1a3e7f8283b8434.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="async_cell" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0-nightly (d5fd09972 2024-01-22)" data-channel="nightly" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../async_cell/index.html">async_cell</a><span class="version">0.2.2</span></h2></div><div class="sidebar-elems"><ul class="block">
            <li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li></ul></section></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../async_cell/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">async_cell</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/async_cell/lib.rs.html#1-786">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The key type of this crate is <a href="sync/struct.AsyncCell.html" title="struct async_cell::sync::AsyncCell"><code>AsyncCell</code></a> which can be
found in both thread-safe and single-threaded variants. It is intended as a
useful async primitive which can replace more expensive channels in a fair
number of cases.</p>
<blockquote>
<p><code>AsyncCell&lt;T&gt;</code> behaves a lot like a <code>Cell&lt;Option&lt;T&gt;&gt;</code> that you can await
on.</p>
</blockquote>
<p>This is used to create futures from a callbacks:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>async_cell::sync::AsyncCell;

<span class="kw">let </span>cell = AsyncCell::shared();
<span class="kw">let </span>future = cell.take_shared();

thread::spawn(<span class="kw">move </span>|| cell.set(<span class="string">"Hello, World!"</span>));

<span class="macro">println!</span>(<span class="string">"{}"</span>, future.<span class="kw">await</span>);</code></pre></div>
<p>You can also use an async_cell for static variable initialization, wherever
the blocking behavior of a <code>OnceCell</code> is unacceptable:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>async_cell::sync::AsyncCell;

<span class="comment">// AsyncCell::new() is const!
</span><span class="kw">static </span>GREETING: AsyncCell&lt;String&gt; = AsyncCell::new();

<span class="comment">// Read the file on a background thread,
// setting a placeholder value if the thread panics.
</span>thread::spawn(|| {
    <span class="kw">let </span>greeting = GREETING.guard(<span class="string">"ERROR"</span>.to_string());
    <span class="kw">let </span>hello = std::fs::read_to_string(<span class="string">"tests/hello.txt"</span>).unwrap();
    greeting.set(hello);
});

<span class="comment">// Do some work while waiting for the file.

// And greet the user!
</span><span class="macro">println!</span>(<span class="string">"{}"</span>, <span class="kw-2">&amp;</span>GREETING.get().<span class="kw">await</span>);</code></pre></div>
<p>Async cells can also be used to react to the latest value of a variable,
since the same cell can be reused as many times as desired. This is one
way <code>AsyncCell</code> differs from a one-shot channel:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>async_cell::sync::AsyncCell;

<span class="comment">// Allocate space for our timer.
</span><span class="kw">let </span>timer = AsyncCell::&lt;i32&gt;::shared();

<span class="comment">// Try to print out the time as fast as it updates.
// Some ticks will be skipped if this loop runs too slowly!
</span><span class="kw">let </span>watcher = timer.take_weak();
spawn(<span class="kw">async move </span>{
    <span class="kw">while let </span><span class="prelude-val">Some</span>(time) = (<span class="kw-2">&amp;</span>watcher).<span class="kw">await </span>{
        <span class="macro">println!</span>(<span class="string">"Launch in T-{} ticks!"</span>, time);
    }
});

<span class="comment">// Begin counting down!
</span><span class="kw">for </span>i <span class="kw">in </span>(<span class="number">0</span>..<span class="number">60</span>).rev() {
    timer.set(i);
}</code></pre></div>
<p>Although this crate contains a number of utility functions, you can often
make due with just <a href="sync/struct.AsyncCell.html#method.new" title="associated function async_cell::sync::AsyncCell::new"><code>AsyncCell::new</code></a>,
<a href="sync/struct.AsyncCell.html#method.set" title="method async_cell::sync::AsyncCell::set"><code>AsyncCell::set</code></a>, and
<a href="sync/struct.AsyncCell.html#method.take" title="method async_cell::sync::AsyncCell::take"><code>AsyncCell::take</code></a>.</p>
<h3 id="limitations"><a class="doc-anchor" href="#limitations">§</a>Limitations</h3>
<p>Cells are not channels! Channels will queue all sent values until a receiver
can process them. Readers of a cell will only ever see the most recently
written value. As an example, imagine a GUI with a text box. An <code>AsyncCell</code>
would be perfect to watch the text content of the box, since it is not
necessary to send the whole thing on every keystroke. But the keystrokes
themselves must be sent to the box via a channel to avoid any getting lost.</p>
<p>Also avoid using <code>AsyncCell</code> in situations with high contention. Cells block
momentarily while cloning values, allocating async callbacks, etc.
As a rule of thumb, try to fill cells from one thread or task and empty from one other.
<em>Although multiple futures can wait on the same cell, that case is not highly optimized.</em></p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="sync/index.html" title="mod async_cell::sync">sync</a></div><div class="desc docblock-short">Types which can be shared across threads.</div></li><li><div class="item-name"><a class="mod" href="unsync/index.html" title="mod async_cell::unsync">unsync</a></div><div class="desc docblock-short">Types for single-threaded and no_std use.</div></li></ul></section></div></main></body></html>