<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Tutorial"><title>futures_signals::tutorial - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-b1a3e7f8283b8434.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="futures_signals" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0-nightly (d5fd09972 2024-01-22)" data-channel="nightly" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../futures_signals/index.html">futures_signals</a><span class="version">0.3.33</span></h2></div><h2 class="location"><a href="#">Module tutorial</a></h2><div class="sidebar-elems"><h2><a href="../index.html">In crate futures_signals</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../futures_signals/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">futures_signals</a>::<wbr><a class="mod" href="#">tutorial</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/futures_signals/lib.rs.html#646">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="tutorial"><a class="doc-anchor" href="#tutorial">§</a>Tutorial</h2>
<p>This tutorial is long, but it’s intended to explain everything you need to
know in order to use Signals.</p>
<p>It is highly recommended to read through all of it.</p>
<h3 id="mutable"><a class="doc-anchor" href="#mutable">§</a><code>Mutable</code></h3>
<p>Before I can fully explain Signals, first I have to explain <a href="../signal/struct.Mutable.html"><code>Mutable</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>futures_signals::signal::Mutable;

<span class="kw">let </span>my_state = Mutable::new(<span class="number">5</span>);</code></pre></div>
<p>The above example creates a new <code>Mutable</code> with an initial value of <code>5</code>.</p>
<p><code>Mutable</code> is very similar to <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> + <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a>:</p>
<ul>
<li>It implements <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> and
<a href="https://doc.rust-lang.org/std/marker/trait.Sync.html"><code>Sync</code></a>,
so it can be sent and used between multiple threads.</li>
<li>It implements <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>,
which will create a new reference to the same <code>Mutable</code> (just like <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a>).</li>
<li>You can retrieve the current value.</li>
<li>You can change the current value.</li>
</ul>
<p>Let’s see it in action:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Acquires a mutable lock on my_state
</span><span class="kw">let </span><span class="kw-2">mut </span>lock = my_state.lock_mut();

<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>lock, <span class="number">5</span>);

<span class="comment">// Changes the current value of my_state to 10
</span><span class="kw-2">*</span>lock = <span class="number">10</span>;

<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>lock, <span class="number">10</span>);</code></pre></div>
<h3 id="for_each"><a class="doc-anchor" href="#for_each">§</a><code>for_each</code></h3>
<p>However, if that was all <code>Mutable</code> could do, it wouldn’t be very useful,
because <code>RwLock</code> already exists!</p>
<p>The major difference between <code>Mutable</code> and <code>RwLock</code> is that it is possible
to be efficiently notified whenever the <code>Mutable</code> changes:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>futures_signals::signal::SignalExt;

<span class="kw">let </span>future = my_state.signal().for_each(|value| {
    <span class="comment">// This code is run for the current value of my_state,
    // and also every time my_state changes
    </span><span class="macro">println!</span>(<span class="string">"{}"</span>, value);
    <span class="kw">async </span>{}
});</code></pre></div>
<p>This is how the <a href="../signal/trait.SignalExt.html#method.for_each"><code>for_each</code></a> method works:</p>
<ol>
<li>
<p>It returns a <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>.</p>
</li>
<li>
<p>When that <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>
is spawned, it will call the <code>|value| { ... }</code> closure with the <em>current
value</em> of <code>my_state</code> (which in this case is <code>10</code>).</p>
</li>
<li>
<p>Then whenever <code>my_state</code> changes it will call the closure again with the new value.</p>
</li>
</ol>
<p>This can be used for all sorts of things, such as automatically updating
your GUI or database whenever the <code>Signal</code> changes.</p>
<p>Just like <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> and
<a href="https://docs.rs/futures/^0.3.15/futures/stream/trait.Stream.html"><code>Stream</code></a>,
when you create a <code>Signal</code> it does not actually do anything until it is spawned.</p>
<p>In order to spawn a <code>Signal</code> you first use the <code>for_each</code> method (as shown
above) to convert it into a <code>Future</code>, and then you spawn that <code>Future</code>.</p>
<p>There are many ways to spawn a <code>Future</code>:</p>
<ul>
<li><a href="https://docs.rs/futures/^0.3.15/futures/executor/fn.block_on.html"><code>block_on(future)</code></a></li>
<li><a href="https://docs.rs/tokio/^1.6.1/tokio/task/fn.spawn.html"><code>tokio::spawn(future)</code></a></li>
<li><a href="https://docs.rs/async-std/^1.9.0/async_std/task/fn.spawn.html"><code>task::spawn(future)</code></a></li>
<li><a href="https://docs.rs/wasm-bindgen-futures/^0.4.24/wasm_bindgen_futures/fn.spawn_local.html"><code>spawn_local(future)</code></a></li>
</ul>
<p>And many more! Because <code>for_each</code> returns a normal <code>Future</code>, anything that
can spawn a <code>Future</code> can also spawn a <code>Signal</code>.</p>
<p>That also means you can use all of the <a href="https://docs.rs/futures/^0.3.15/futures/future/trait.FutureExt.html"><code>FutureExt</code></a>
methods on it as well.</p>
<h3 id="to_stream"><a class="doc-anchor" href="#to_stream">§</a><code>to_stream</code></h3>
<p>If you need more control, you can use <a href="../signal/trait.SignalExt.html#method.to_stream"><code>to_stream</code></a> instead:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>stream = my_state.signal().to_stream();</code></pre></div>
<p>This returns a <a href="https://docs.rs/futures/^0.3.15/futures/stream/trait.Stream.html"><code>Stream</code></a>
of values (starting with the current value of <code>my_state</code>, and then followed
by the changes to <code>my_state</code>).</p>
<p>You can use all of the <a href="https://docs.rs/futures/^0.3.15/futures/stream/trait.StreamExt.html"><code>StreamExt</code></a>
methods on it, just like with any other
<a href="https://docs.rs/futures/^0.3.15/futures/stream/trait.Stream.html"><code>Stream</code></a>.</p>
<h3 id="signal"><a class="doc-anchor" href="#signal">§</a><code>signal</code></h3>
<p>You might be wondering why you have to call the <code>signal()</code> method: why can’t
you just use the <code>Mutable</code> directly?</p>
<p>There are actually three different methods, which you can use depending on
your needs:</p>
<ol>
<li>
<p><a href="../signal/struct.ReadOnlyMutable.html#method.signal"><code>signal()</code></a> is the
most convenient but it requires the value to be <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>.</p>
</li>
<li>
<p><a href="../signal/struct.ReadOnlyMutable.html#method.signal_cloned"><code>signal_cloned()</code></a>
requires the value to be <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>.</p>
</li>
<li>
<p><a href="../signal/struct.ReadOnlyMutable.html#method.signal_ref"><code>signal_ref(|x| { ... })</code></a>
gives the closure a <code>&amp;</code> reference to the value, so the value doesn’t need
to be <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a> or
<a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>, but
instead the value is determined by the closure.</p>
<p>This is the most flexible and also the fastest, but it is the longest and
most cumbersome to use.</p>
</li>
</ol>
<p>In addition, it is possible to call the <code>signal</code> methods multiple times
(and mix-and-match them):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>signal1 = my_state.signal();
<span class="kw">let </span>signal2 = my_state.signal();
<span class="kw">let </span>signal3 = my_state.signal_cloned();
<span class="kw">let </span>signal4 = my_state.signal_ref(|x| <span class="kw-2">*</span>x + <span class="number">10</span>);</code></pre></div>
<p>When the <code>Mutable</code> changes, <em>all</em> of its <code>Signal</code>s are notified.</p>
<p>This turns out to be very useful in practice: it’s common to put your
program’s state inside of a global <code>Mutable</code> (or multiple <code>Mutable</code>s) and
then share it in various places throughout your program.</p>
<p>Lastly, there is a big difference between <code>Mutable</code> and <code>Signal</code>:
a <code>Signal</code> can only be notified when its value changes. However, a <code>Mutable</code>
can do a lot more than that, because it can retrieve the current value, and
it can also set the value.</p>
<h3 id="signal-1"><a class="doc-anchor" href="#signal-1">§</a><code>Signal</code></h3>
<p>Now that I’ve fully explained <code>Mutable</code>, I can finally explain <a href="../signal/trait.Signal.html"><code>Signal</code></a>.</p>
<p>A <code>Signal</code> is an efficient zero-cost value which changes over time, and you
can be efficiently notified when it changes.</p>
<p>Just like <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a>
and <a href="https://docs.rs/futures/^0.3.15/futures/stream/trait.Stream.html"><code>Stream</code></a>,
<code>Signal</code>s are inlined and compiled into a very efficient state machine.
Most of the time they are fully stack allocated (<em>no</em> heap allocation).</p>
<p>And in the rare cases that they heap allocate they only do it <em>once</em>, when
the <code>Signal</code> is created, not while the <code>Signal</code> is running. This means the
performance is excellent, even with millions of <code>Signal</code>s running simultaneously.</p>
<p>Just like <a href="https://docs.rs/futures/^0.3.15/futures/future/trait.FutureExt.html"><code>FutureExt</code></a> and
<a href="https://docs.rs/futures/0.3.15/futures/stream/trait.StreamExt.html"><code>StreamExt</code></a>,
the <a href="../signal/trait.SignalExt.html"><code>SignalExt</code></a> trait has many useful
methods, and most of them return a <code>Signal</code> so they can be chained:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>output = my_state.signal()
    .map(|value| value + <span class="number">5</span>)
    .map_future(|value| do_some_async_calculation(value))
    .dedupe();</code></pre></div>
<p>Let’s say that the current value of <code>my_state</code> is <code>10</code>.</p>
<p>When <code>output</code> is spawned it will call the <code>|value| value + 5</code> closure with
the current value of <code>my_value</code> (the closure returns <code>10 + 5</code>, which is <code>15</code>).</p>
<p>Then it calls <code>do_some_async_calculation(15)</code> which returns a <code>Future</code>.
When that <code>Future</code> finishes, <code>dedupe</code> checks if the return value is
different from the previous value (using <code>==</code>), and if so then <code>output</code>
notifies with the new value.</p>
<p>It automatically repeats this process whenever <code>my_state</code> changes, ensuring
that <code>output</code> is always kept in sync with <code>my_state</code>.</p>
<p>It is also possible to use <a href="../macro.map_ref.html"><code>map_ref</code></a> which is similar
to <a href="../signal/trait.SignalExt.html#method.map"><code>map</code></a> except it allows you
to use multiple input <code>Signal</code>s:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>futures_signals::map_ref;

<span class="kw">let </span>output = <span class="macro">map_ref! </span>{
    <span class="kw">let </span>foo = foo.signal(),
    <span class="kw">let </span>bar = bar.signal(),
    <span class="kw">let </span>qux = qux.signal() =&gt;
    <span class="kw-2">*</span>foo + <span class="kw-2">*</span>bar + <span class="kw-2">*</span>qux
};</code></pre></div>
<p>In this case <code>map_ref</code> is depending on three <code>Signal</code>s: <code>foo</code>, <code>bar</code>, and <code>qux</code>.</p>
<p>Whenever any of those <code>Signal</code>s changes, it will rerun the <code>*foo + *bar + *qux</code>
code.</p>
<p>This means that <code>output</code> will always be equal to the sum of <code>foo</code>, <code>bar</code>, and <code>qux</code>.</p>
<h3 id="signals-are-lossy"><a class="doc-anchor" href="#signals-are-lossy">§</a>Signals are lossy</h3>
<p>It is important to understand that <code>for_each</code>, <code>to_stream</code>, and <em>all</em>
other <code>SignalExt</code> methods are <em>lossy</em>: they might skip changes.</p>
<p>That is because they only care about the <em>most recent value</em>. So if the
value changes multiple times in a short period of time it will only detect
the most recent change.</p>
<p>Here is an example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>my_state.set(<span class="number">2</span>);
my_state.set(<span class="number">3</span>);</code></pre></div>
<p>In this case it will only detect the <code>3</code> change. The <code>2</code> change is
completely ignored, like as if it never happened.</p>
<p>This is an intentional design choice: it is necessary for correctness and
performance.</p>
<p>So whenever you are using a <code>Signal</code>, you must <em><strong>not</strong></em> rely on it being
updated for intermediate values.</p>
<p>That might sound like a problem, but it’s actually not a problem at all:
<code>Signal</code>s are guaranteed to always be updated with the most recent value,
so it’s <em>only</em> intermediate values which aren’t guaranteed.</p>
<p>This is similar to <code>RwLock</code>, which also does not give you access to past
values (only the current value). So as long as your program only cares about
the most recent value, then <code>Signal</code>s will work perfectly.</p>
<p>If you really <em>do</em> need all intermediate values (not just the most recent),
then using a <a href="https://docs.rs/futures/^0.3.15/futures/stream/trait.Stream.html"><code>Stream</code></a>
(such as <a href="https://docs.rs/futures/^0.3.15/futures/channel/mpsc/fn.unbounded.html"><code>futures::channel::mpsc::unbounded</code></a>)
would be a great choice. In that case you will pay a small performance
penalty, because it has to hold the values in a queue.</p>
<p>And of course you can freely mix <code>Future</code>s, <code>Stream</code>s, and <code>Signal</code>s in
your program, using each one where it is appropriate.</p>
<h3 id="mutablevec"><a class="doc-anchor" href="#mutablevec">§</a><code>MutableVec</code></h3>
<p>In addition to <code>Mutable</code> and <code>Signal</code>, there is also <a href="../signal_vec/struct.MutableVec.html"><code>MutableVec</code></a>,
<a href="../signal_vec/trait.SignalVec.html"><code>SignalVec</code></a>, and <a href="../signal_vec/trait.SignalVecExt.html"><code>SignalVecExt</code></a>.</p>
<p>As its name suggests, <code>MutableVec&lt;A&gt;</code> is very similar to <code>Mutable&lt;Vec&lt;A&gt;&gt;</code>,
except it’s <em>dramatically</em> more efficient: rather than being notified with
the new <code>Vec</code>, instead you are notified with the <em>difference</em> between the
old <code>Vec</code> and the new <code>Vec</code>.</p>
<p>Here is an example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>futures_signals::signal_vec::MutableVec;

<span class="kw">let </span>my_vec: MutableVec&lt;u32&gt; = MutableVec::new();</code></pre></div>
<p>The above creates a new empty <code>MutableVec</code>.</p>
<p>You can then use <a href="../signal_vec/struct.MutableVec.html#method.lock_mut"><code>lock_mut</code></a>,
which returns a lock. As its name implies, while you are holding the lock
you have exclusive mutable access to the <code>MutableVec</code>.</p>
<p>The lock contains many of the <code>Vec</code> methods:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>lock = my_vec.lock_mut();
lock.push(<span class="number">1</span>);
lock.insert(<span class="number">0</span>, <span class="number">2</span>);
lock.remove(<span class="number">0</span>);
lock.pop().unwrap();
<span class="comment">// And a lot more!</span></code></pre></div>
<p>The insertion methods require <code>Copy</code>, but there are also <code>_cloned</code> variants
which require <code>Clone</code> instead:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>lock.push_cloned(<span class="number">1</span>);
lock.insert_cloned(<span class="number">0</span>, <span class="number">2</span>);
<span class="comment">// etc.</span></code></pre></div>
<p>This is needed because when you insert a new value, it has to send a copy to
all of the <code>SignalVec</code>s which are listening to changes.</p>
<p>The lock also has a <code>Deref</code> implementation for <code>&amp;[T]</code>, so you can use <em>all</em>
of the immutable <a href="https://doc.rust-lang.org/std/primitive.slice.html"><code>slice</code></a>
methods on it:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let _ </span>= lock[<span class="number">0</span>];
<span class="kw">let _ </span>= lock.len();
<span class="kw">let _ </span>= lock.last();
<span class="kw">let _ </span>= lock.iter();
<span class="comment">// And a lot more!</span></code></pre></div>
<p>Lastly, you can use the <a href="../signal_vec/struct.MutableVec.html#method.signal_vec"><code>signal_vec()</code></a>
or <a href="../signal_vec/struct.MutableVec.html#method.signal_vec_cloned"><code>signal_vec_cloned()</code></a>
methods to convert it into a <code>SignalVec</code>, and then you can use the
<a href="../signal_vec/trait.SignalVecExt.html#method.for_each"><code>for_each</code></a> method
to be efficiently notified when it changes:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>futures_signals::signal_vec::{SignalVecExt, VecDiff};

<span class="kw">let </span>future = my_vec.signal_vec().for_each(|change| {
    <span class="kw">match </span>change {
        VecDiff::Replace { values } =&gt; {
            <span class="comment">// ...
        </span>},
        VecDiff::InsertAt { index, value } =&gt; {
            <span class="comment">// ...
        </span>},
        VecDiff::UpdateAt { index, value } =&gt; {
            <span class="comment">// ...
        </span>},
        VecDiff::RemoveAt { index } =&gt; {
            <span class="comment">// ...
        </span>},
        VecDiff::Move { old_index, new_index } =&gt; {
            <span class="comment">// ...
        </span>},
        VecDiff::Push { value } =&gt; {
            <span class="comment">// ...
        </span>},
        VecDiff::Pop {} =&gt; {
            <span class="comment">// ...
        </span>},
        VecDiff::Clear {} =&gt; {
            <span class="comment">// ...
        </span>},
    }

    <span class="kw">async </span>{}
});</code></pre></div>
<p>Just like <code>SignalExt::for_each</code>, the <code>SignalVecExt::for_each</code> method returns
a <code>Future</code>.</p>
<p>When that <code>Future</code> is spawned:</p>
<ol>
<li>
<p>If the <code>SignalVec</code> already has values, it calls the closure with
<code>VecDiff::Replace</code>, which contains the current values for the <code>SignalVec</code>.</p>
</li>
<li>
<p>If the <code>SignalVec</code> doesn’t have any values, it doesn’t call the closure.</p>
</li>
<li>
<p>Whenever the <code>SignalVec</code> changes, it calls the closure with the <code>VecDiff</code>
for the change.</p>
</li>
</ol>
<p>Unlike <code>SignalExt::for_each</code>, the <code>SignalVecExt::for_each</code> method calls the
closure with a <a href="../signal_vec/enum.VecDiff.html"><code>VecDiff</code></a>, which contains
the difference between the new <code>Vec</code> and the old <code>Vec</code>.</p>
<p>As an example, if you call <code>lock.push(5)</code>, then the closure will be called with <code>VecDiff::Push { value: 5 }</code></p>
<p>And if you call <code>lock.insert(3, 10)</code>, then the closure will be called with <code>VecDiff::InsertAt { index: 3, value: 10 }</code></p>
<p>This allows you to very efficiently update based only on that specific change.</p>
<p>For example, if you are automatically saving the <code>MutableVec</code> to a database
whenever it changes, you don’t need to save the entire <code>MutableVec</code> when it
changes, you only need to save the individual changes. This means that it will
often be constant <code>O(1)</code> time, no matter how big the <code>MutableVec</code> is.</p>
<h3 id="signalvecext"><a class="doc-anchor" href="#signalvecext">§</a><code>SignalVecExt</code></h3>
<p>Just like <code>SignalExt</code>, <a href="../signal_vec/trait.SignalVecExt.html"><code>SignalVecExt</code></a>
has a lot of useful methods, and most of them return a <code>SignalVec</code> so they
can be chained:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>output = my_vec.signal_vec()
    .filter(|value| <span class="kw-2">*</span>value &lt; <span class="number">5</span>)
    .map(|value| value + <span class="number">10</span>);</code></pre></div>
<p>They are generally very efficient (e.g. <code>map</code> is constant time, no matter
how big the <code>SignalVec</code> is, and <code>filter</code> is linear time).</p>
<h3 id="signalvec-is-lossless"><a class="doc-anchor" href="#signalvec-is-lossless">§</a>SignalVec is lossless</h3>
<p>Unlike <code>Signal</code>, it is guaranteed that the <code>SignalVec</code> will never skip a
change. In addition, the changes will always be in the correct order.</p>
<p>This is because it is notifying with the difference between the old <code>Vec</code>
and the new <code>Vec</code>, so it is very important that it is in the correct order,
and that it doesn’t skip anything!</p>
<p>That does mean that <code>MutableVec</code> needs to maintain a queue of changes, so
this has a minor performance cost.</p>
<p>But because it’s so efficient to update based upon the difference between
the old and new <code>Vec</code>, it’s still often faster to use <code>MutableVec&lt;A&gt;</code> rather
than <code>Mutable&lt;Vec&lt;A&gt;&gt;</code>, even with the extra performance overhead.</p>
<p>In addition, even though <code>MutableVec</code> needs to maintain a queue, <code>SignalVec</code>
does <em><strong>not</strong></em>, so it’s quite efficient.</p>
<p>If you call a <code>MutableVec</code> method which doesn’t <em>actually</em> make any changes,
then it will not notify at all:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>my_vec.lock_mut().retain(|<span class="kw">_</span>| { <span class="bool-val">true </span>});</code></pre></div>
<p>The <a href="../signal_vec/struct.MutableVecLockMut.html#method.retain"><code>MutableVec::retain</code></a>
method is the same as <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.retain"><code>Vec::retain</code></a>,
it calls the closure for each value in the <code>MutableVec</code>, and if the closure
returns <code>false</code> it removes that value from the <code>MutableVec</code>.</p>
<p>But in the above example, it never returns <code>false</code>, so it never removes
anything, so it doesn’t notify.</p>
<p>Also, even though it’s guaranteed to send a notification for each change,
the notification might be different than what you expect.</p>
<p>For example, when calling the <code>retain</code> method, it will send out a
notification for each change, so if <code>retain</code> removes 5 values it will send
out 5 notifications.</p>
<p>But, contrary to what you might expect, the notifications are in the reverse
order: it sends notifications for the right-most values first, and
notifications for the left-most values last. In addition, it sends a mixture
of <code>VecDiff::Pop</code> and <code>VecDiff::RemoveAt</code>.</p>
<p>Another example is that <a href="../signal_vec/struct.MutableVecLockMut.html#method.remove"><code>remove</code></a>
might notify with either <code>VecDiff::RemoveAt</code> or <code>VecDiff::Pop</code> depending on
whether it removed the last value or not.</p>
<p>The reason for this is performance, and you should <em><strong>not</strong></em> rely
upon it: the behavior of exactly which notifications are sent is an
implementation detail.</p>
<p>However, there is one thing you <em>can</em> rely on: if you apply the
notifications in the same order they are received, it will exactly recreate
the <code>SignalVec</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>copied_vec = <span class="macro">vec!</span>[];

<span class="kw">let </span>future = my_vec.signal_vec().for_each(<span class="kw">move </span>|change| {
    <span class="kw">match </span>change {
        VecDiff::Replace { values } =&gt; {
            copied_vec = values;
        },
        VecDiff::InsertAt { index, value } =&gt; {
            copied_vec.insert(index, value);
        },
        VecDiff::UpdateAt { index, value } =&gt; {
            copied_vec[index] = value;
        },
        VecDiff::RemoveAt { index } =&gt; {
            copied_vec.remove(index);
        },
        VecDiff::Move { old_index, new_index } =&gt; {
            <span class="kw">let </span>value = copied_vec.remove(old_index);
            copied_vec.insert(new_index, value);
        },
        VecDiff::Push { value } =&gt; {
            copied_vec.push(value);
        },
        VecDiff::Pop {} =&gt; {
            copied_vec.pop().unwrap();
        },
        VecDiff::Clear {} =&gt; {
            copied_vec.clear();
        },
    }

    <span class="kw">async </span>{}
});</code></pre></div>
<p>In the above example, <code>copied_vec</code> is guaranteed to have exactly the same
values as <code>my_vec</code>, in the same order as <code>my_vec</code>.</p>
<p>But even though the <em>end result</em> is guaranteed to be the same, the order of
the individual changes is an unspecified implementation detail.</p>
<h3 id="mutablebtreemap"><a class="doc-anchor" href="#mutablebtreemap">§</a><code>MutableBTreeMap</code></h3>
<p>Just like how <code>MutableVec</code> is a <code>Signal</code> version of <code>Vec</code>, there is also
<a href="../signal_map/struct.MutableBTreeMap.html"><code>MutableBTreeMap</code></a> which is a
<code>Signal</code> version of <a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code>BTreeMap</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>futures_signals::signal_map::MutableBTreeMap;

<span class="kw">let </span>map = MutableBTreeMap::new();

<span class="kw">let </span><span class="kw-2">mut </span>lock = map.lock_mut();
lock.insert(<span class="string">"foo"</span>, <span class="number">5</span>);
lock.insert(<span class="string">"bar"</span>, <span class="number">10</span>);</code></pre></div>
<p>Similar to <code>MutableVec</code>, it notifies with a <a href="../signal_map/enum.MapDiff.html"><code>MapDiff</code></a>,
and of course it supports <a href="../signal_map/trait.SignalMap.html"><code>SignalMap</code></a>
and <a href="../signal_map/trait.SignalMapExt.html"><code>SignalMapExt</code></a> for efficient
transformations and notifications:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>futures_signals::signal_map::{SignalMapExt, MapDiff};

<span class="kw">let </span>output = map.signal_map().for_each(|change| {
    <span class="kw">match </span>change {
        MapDiff::Replace { entries } =&gt; {
            <span class="comment">// ...
        </span>},
        MapDiff::Insert { key, value } =&gt; {
            <span class="comment">// ...
        </span>},
        MapDiff::Update { key, value } =&gt; {
            <span class="comment">// ...
        </span>},
        MapDiff::Remove { key } =&gt; {
            <span class="comment">// ...
        </span>},
        MapDiff::Clear {} =&gt; {
            <span class="comment">// ...
        </span>},
    }

    <span class="kw">async </span>{}
});</code></pre></div>
<h3 id="end"><a class="doc-anchor" href="#end">§</a>End</h3>
<p>And that’s the end of the tutorial! We didn’t cover every method, but we
covered enough for you to get started.</p>
<p>You can look at the documentation for information on every method (there’s a
lot of useful stuff in there!).</p>
</div></details></section></div></main></body></html>